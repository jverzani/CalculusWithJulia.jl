var documenterSearchIndex = {"docs":
[{"location":"#CalculusWithJulia.jl","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.jl","text":"","category":"section"},{"location":"","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.jl","text":"Documentation for CalculusWithJulia.jl, a package to accompany  the notes \"Calculus with Julia\" for using Julia for Calculus.","category":"page"},{"location":"","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.jl","text":"To suggest corrections to the notes, please submit a pull request to https://github.com/jverzani/CalculusWithJuliaNotes.jl/. The Quarto pages makes this easy, as they have an \"Edit this page\" link.","category":"page"},{"location":"","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.jl","text":"","category":"page"},{"location":"#Index","page":"CalculusWithJulia.jl","title":"Index","text":"","category":"section"},{"location":"","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.jl","text":"Modules = [CalculusWithJulia]","category":"page"},{"location":"#CalculusWithJulia.CalculusWithJulia","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.CalculusWithJulia","text":"CalculusWithJulia\n\nA package to accompany notes at https://calculuswithjulia.github.io on using Julia for topics from the calculus sequence.\n\nThis package does two things:\n\nIt loads a few other packages making it easier to use (and install) the functionality provided by them and\nIt defines a handful of functions for convenience. The exported ones\n\nare e, unzip, rangeclamp tangent, secant, D (and the prime notation), divergence, gradient, curl, and ∇, along with some plotting functions\n\nPackages loaded by CalculusWithJulia\n\nThe SpecialFunctions is loaded giving access to a few special functions used in these notes, e.g., airyai, gamma\nThe ForwardDiff package is loaded giving access to its  derivative,  gradient, jacobian, and hessian functions for finding automatic derivatives of functions. In addition, this package defines ' (for functions) to return a derivative (which commits type piracy), ∇ to find the gradient (∇(f)), the divergence (∇⋅F). and the curl (∇×F), along with divergence and curl.\n\nThe LinearAlgebra package is loaded for access to several of its functions fr working with vectors norm, cdot (⋅), cross (×), det.\nThe PlotUtils package is loaded so that its adapted_grid function is available.\n\nPackages with extra features added when loaded\n\nThe Julia package Requires allows for additional code to be run when another package is loaded. The following packages have additional code to load:\n\nSymPy: for symbolic math.\nPlots: the Plots package provides a plotting interface.\n\nSeveral plot recipes are provided to ease the creation of plots in the notes. plotif, trimplot, and signchart are used for plotting univariate functions; plot_polar and plot_parametric are used to plot curves in 2 or 3 dimensions; plot_parametric also makes the plotting og parameterically defined surfaces easier; vectorfieldplot and vectorfieldplot3d can be used to plot vector fields; and arrow is a simplified interface to quiver that also indicates 3D vectors.\n\nThe plot_implicit function can plot 2D implicit plots. (It is borrowed from ImplicitPlots.jl, which is avoided, as it has dependencies that hold other packages back.)\n\nOther packages with a recurring role in the accompanying notes:\n\nRoots is used to find zeros of univariate functions\nSymPy for symbolic math\nQuadGK and HCubature are used for numeric integration\n\n\n\n\n\n","category":"module"},{"location":"#CalculusWithJulia.D","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.D","text":"D(f)\n\nFunction interface to ForwardDiff.derivative.\n\nAlso overrides f' to take take a derivative.\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.arrow","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.arrow","text":"arrow!(p, v)\n\nAdd the vector v to the plot anchored at p.\n\nThis would just be a call to quiver, but there is no 3-D version of that. As well, the syntax for quiver is a bit awkward for plotting just a single arrow. (Though efficient if plotting many).\n\nusing Plots\nr(t) = [sin(t), cos(t), t]\nrp(t) = [cos(t), -sin(t), 1]\nplot(unzip(r, 0, 2pi)...)\nt0 = 1\narrow!(r(t0), rp(t0))\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.curl-Tuple{Matrix}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.curl","text":"curl(F)\n\nFind curl of a 2 or 3-D vector field.\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.divergence-Tuple{Tuple}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.divergence","text":"divergence(F)\n\nFind divergence of a 3-D vector vield.\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.fisheye-Tuple{Any}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.fisheye","text":"fisheye(f)\n\nTransform f defined on (-∞, ∞) to a new function whose domain is in (-π/2, π/2) and range is within (-π/2, π/2). Useful for finding all zeros over the real line. For example\n\nf(x) = 1 + 100x^2 - x^3\nfzeros(f, -100, 100) # empty just misses the zero found with:\nfzeros(fisheye(f), -pi/2, pi/2) .|> tan  # finds 100.19469143521222, not perfect but easy to get\n\nBy Gunter Fuchs.\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.fubini-Tuple{Any, Any}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.fubini","text":"fubini(f, [zs], [ys], xs; rtol=missing, kws...)\n\nIntegrate f of 1, 2, or 3 input variables.\n\nThe zs may depend (x,y), the ys may depend on x\n\nExamples\n\n# integrate over the unit square\nfubini((x,y) -> sin(x-y), (0,1), (0,1))\n\n# integrate over a triangle\nfubini((x,y) -> 1, (0,identity), (0,1 ))\n\n#\nf(x,y,z) = x*y^2*z^3\nfubini(f, (0,(x,y) ->  x+ y), (0, x -> x), (0,1))\n\n!!! Note     This uses nested calls to quadgk. The use of hcubature is recommended, typically after a change of variables to make a rectangular domain. The relative tolerance increases at each nested level.\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.lim-Tuple{Function, Real}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.lim","text":"lim(f, c; n=6, m=1, dir=\"+-\")\nlim(f, c, dir; n-5)\n\nMeans to generate numeric table of values of f as h gets close to c.\n\nn, m: powers of 10 to add (subtract) to (from) c.\ndir: Either \"+-\" (show left and right), \"+\" (right limit), or \"-\" (left limit). Can also use functions +, -, ±.\n\nExample:\n\njulia> f(x) = sin(x) / x\nf (generic function with 1 method)\n\njulia> lim(f, 0)\n 0.1        0.9983341664682815\n 0.01       0.9999833334166665\n 0.001      0.9999998333333416\n 0.0001     0.9999999983333334\n 1.0e-5     0.9999999999833332\n 1.0e-6     0.9999999999998334\n   ⋮          ⋮\n   c          L?\n   ⋮          ⋮\n-1.0e-6     0.9999999999998334\n-1.0e-5     0.9999999999833332\n-0.0001     0.9999999983333334\n-0.001      0.9999998333333416\n-0.01       0.9999833334166665\n-0.1        0.9983341664682815\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.newton_plot!","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.newton_plot!","text":"newton_plot!(f, x0; steps=5, annotate_steps::Int=0, kwargs...)\n\nAdd trace of Newton's method to plot.\n\nsteps: how many steps from x0 to illustrate\nannotate_steps::Int: how may steps to annotate\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.newton_vis","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.newton_vis","text":"newton_vis(f, x0, a=Inf, b=-Inf; steps=5, kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.plot_implicit_surface","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.plot_implicit_surface","text":"Visualize `F(x,y,z) = c` by plotting assorted contour lines\n\nThis graphic makes slices in the x, y, and/or z direction of the 3-D level surface and plots them accordingly. Which slices (and their colors) are specified through a dictionary.\n\nExamples:\n\nF(x,y,z) = x^2 + y^2 + x^2\nplot_implicit_surface(F, 20)  # 20 slices in z direction\nplot_implicit_surface(F, 20, slices=Dict(:x=>:blue, :y=>:red, :z=>:green), nlevels=6) # all 3 shown\n\n# A heart\na,b = 1,3\nF(x,y,z) = (x^2+((1+b)*y)^2+z^2-1)^3-x^2*z^3-a*y^2*z^3\nplot_implicit_surface(F, xlims=-2..2,ylims=-1..1,zlims=-1..2)\n\nNote: Idea from.\n\nNot exported.\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.plot_parametric","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.plot_parametric","text":"plot_parametric(ab, r; kwargs...)\nplot_parametric!(ab, r; kwargs...)\nplot_parametric(u, v, F; kwargs...)\nplot_parametric!(u, v, F; kwargs...)\n\nMake a parametric plot of a space curve or parametrized surface\n\nThe intervals to plot over are specifed using a..b notation, from IntervalSets\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.plotif","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.plotif","text":"plotif(f, g, a, b)\n\nPlot of f over [a,b] with the intervals where g ≥ 0 highlighted in many ways.\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.rangeclamp","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.rangeclamp","text":"rangeclamp(f, hi=20, lo=-hi; replacement=NaN)\n\nModify f so that values of f(x) outside of [lo,hi] are replaced by replacement.\n\nExamples\n\nf(x) = 1/x\nplot(rangeclamp(f), -1, 1)\nplot(rangeclamp(f, 10), -1, 1) # no `abs(y)` values exceeding 10\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.riemann-Tuple{Function, Real, Real, Int64}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.riemann","text":"riemann(f, a, b, n; method=\"right\"\n\nCompute an approximations to the definite integral of f over [a,b] using an equal-sized partition of size n+1.\n\nmethod: \"right\" (default), \"left\", \"trapezoid\", \"simpsons\", \"ct\", \"m̃\" (minimum over interval), \"M̃\" (maximum over interval)\n\nExample:\n\nf(x) = exp(x^2)\nriemann(f, 0, 1, 1000)   # default right-Riemann sums\nriemann(f, 0, 1, 1000; method=\"left\")       # left sums\nriemann(f, 0, 1, 1000; method=\"trapezoid\")  # use trapezoid rule\nriemann(f, 0, 1, 1000; method=\"simpsons\")   # use Simpson's rule\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.riemann_plot!","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.riemann_plot!","text":"riemann_plot!(f, a, b, n; method=\"method\", fill, kwargs...)\nriemann_plot(f, a, b, n; method=\"method\", fill, kwargs...)\n\nAdd visualization of riemann sum in a layer.\n\nmethod: one of right, left, trapezoid, simpsons\nfill: to specify fill color, something like (\"green\", 0.25, 0) will fill in green with an alpha transparency.\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.secant-Tuple{Any, Any, Any}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.secant","text":"secant(f::Function, a, b)\n\nReturns a function describing the secant line to the graph of f at x=a and x=b.\n\nExample. Where does the secant line intersect the y axis?\n\nf(x) = sin(x)\na, b = pi/4, pi/3\nsl(x) = secant(f, a, b)(x)  # or sl = sl(f, a, b) to use a non-generic function\nsl(0)\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.sign_chart-Tuple{Any, Any, Any}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.sign_chart","text":"sign_chart(f, a, b; atol=1e-4)\n\nCreate a sign chart for f over (a,b). Returns a collection of named tuples, each with an identified zero or vertical asymptote and the corresponding sign change. The tolerance is used to disambiguate numerically found values.\n\nExample\n\njulia> sign_chart(x -> (x-1/2)/(x*(1-x)), 0, 1)\n3-element Vector{NamedTuple{(:zero_oo_NaN, :sign_change)}}:\n (zero_oo_NaN = 0.0, sign_change = an endpoint)\n (zero_oo_NaN = 0.5, sign_change = - to +)\n (zero_oo_NaN = 1.0, sign_change = an endpoint)\n\nnote: Warning\nThis uses find_zeros to find zeros of f and x -> 1/f(x). The find_zeros function is a hueristic and can miss answers.\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.signchart","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.signchart","text":"signchart(f, a, b)\n\nPlot f over a,b with different color when negative.\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.tangent-Tuple{Any, Any}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.tangent","text":"tangent(f::Function, c)\n\nReturns a function describing the tangent line to the graph of f at x=c.\n\nExample. Where does the tangent line intersect the y axis?\n\nf(x) = sin(x)\ntl(x) = tangent(f, pi/4)(x)  # or tl = tangent(f, pi/3) to use a non-generic function\ntl(0)\n\nUses the automatic derivative of f to find the slope of the tangent line at x=c.\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.trimplot","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.trimplot","text":"trimplot(f, a, b, c=20; kwargs...)\n\nPlot f over [a,b] but break graph if it exceeds c in absolute value.\n\n\n\n\n\n","category":"function"},{"location":"#CalculusWithJulia.unzip-Tuple{Vector}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.unzip","text":"unzip(vs)\nunzip(v1, v2, ...)\nunzip(r::Function, a, b)\n\nTake a vector of points described by vectors (as returned by, say r(t)=[sin(t),cos(t)], r.([1,2,3]), and return a tuple of collected x values, y values, and optionally z values.\n\nWrapper around the invert function of SplitApplyCombine.\n\nIf the argument is specified as a comma separated collection of vectors, then these are combined and passed along.\n\nIf the argument is a function and two end points, then the function is evaluated at 100 points between a and b.\n\nThis is useful for plotting when the data is more conveniently represented in terms of vectors, but the plotting interface requires the x and y values collected.\n\nExamples:\n\nusing Plots\nr(t) = [sin(t), cos(t)]\nrp(t) = [cos(t), -sin(t)]\nplot(unzip(r, 0, 2pi)...)  # calls plot(xs, ys)\n\nt0, t1 = pi/6, pi/4\n\np, v = r(t0), rp(t0)\nplot!(unzip(p, p+v)...)  # connect p to p+v with line\n\np, v = r(t1), rp(t1)\nquiver!(unzip([p])..., quiver=unzip([v]))\n\nBased on unzip from the Plots package. Implemented through invert of SplitApplyCombine\n\nNote: for a vector of points, xs, each of length 2, a similar functionality would be (first.(xs), last.(xs)). If each point had length 3, then with second(x)=x[2], a similar functionality would be (first.(xs), second.(xs), last.(xs)).\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.uvec-Tuple{Any}","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.uvec","text":"uvec(x)\n\nHelper to find a unit vector.\n\n\n\n\n\n","category":"method"},{"location":"#CalculusWithJulia.vectorfieldplot","page":"CalculusWithJulia.jl","title":"CalculusWithJulia.vectorfieldplot","text":"vectorfieldplot(V; xlim=(-5,5), ylim=(-5,5), n=10; kwargs...)\n\nV is a function that takes a point and returns a vector (2D dimensions), such as V(x) = x[1]^2 + x[2]^2.\n\nThe grid xlim × ylim is paritioned into (n+1) × (n+1) points. At each point, pt, a vector proportional to V(pt) is drawn.\n\nThis is written to add to an existing plot.\n\nplot()  # make a plot\nV(x,y) = [x, y-x]\nvectorfield_plot!(p, V)\np\n\n\n\n\n\n","category":"function"}]
}
