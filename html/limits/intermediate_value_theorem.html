<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.1/dist/umd/popper.min.js" integrity="sha384-SR1sx49pcuLnqZUnnPwx6FCym0wLsk5JZuNx2bPPENzswTNFaQU1RDvt3wT4gWFG" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.min.js" integrity="sha384-j0CNLUeiqtyaRmlzUHCPZ+Gy5fQu0dQ6eZ/xAww941Ai1SxSY+0EQqNXNE6DZiVc" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">


<style>
.julia {display: block; font-family: "Source Code Pro";
        color:#0033CC;
        }
.hljl {font-family: "Source Code Pro";
        color:#0033CC;
      }
.output, .julia-error {
    border-left: thick solid #ff0000;
    padding: 5px;
    padding-left: 10px;
    margin-bottom: 15px;
    background-color: #f5f5f5;
}
body { padding-top: 60px;
}
.output {color:#0033CC;}
h5:before {content:"\2746\ ";}
h6:before {content:"\2742\ ";}
pre {display: block;}
th, td {
  padding: 5px;
  text-align: left;
  border-bottom: 1px solid #ddd;
}
tr:hover {background-color: #f5f5f5;}

.admonition-title:before {content:"\2746\ ";}
.admonition-title { color:#0033CC}

main > .container {
  padding: 60px 15px 0;
}

blockquote {
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
  quotes: "\201C""\201D""\2018""\2019";
}
</style>

<!--   padding: 0.5em 10px; .julia:before {content: "julia> "} -->

<style></style>

<script src="https://code.jquery.com/jquery.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/katex.min.css" integrity="sha384-ThssJ7YtjywV52Gj4JE/1SQEDoMEckXyhkFVwaf4nDSm5OBlXeedVYjuuUd0Yua+" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/katex.min.js" integrity="sha384-Bi8OWqMXO1ta+a4EPkZv7bYGIes7C3krGSZoTGNTAnAn5eYQc7IIXrJ/7ck1drAi" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
	onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true},
	      {left: "\\begin{equation}", right: "\\end{equation}", display: true},
              {left: "\\begin{align}", right: "\\end{align}", display: true},
	      {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
	      {left: "\\begin{gather}", right: "\\end{gather}", display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
    });
</script>
<script>
window.PlotlyConfig = {MathJaxConfig: 'local'}
</script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<!-- highlight Julia Code -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/julia.min.js"></script>

<script type="text/javascript">
$( document ).ready(function() {
  $("h1").each(function(index) {
       var title = $( this ).text()
       $("#page_title").html("<strong>" + title + "</strong>");
       document.title = title
  });
  $( "h2" ).each(function( index ) {
    var nm =  $( this ).text();
    var id = $.trim(nm).replace(/ /g,'');
    this.id = id
    $("#page_dropdown").append("<li><a class='dropdown-item' href='#" + id + "'>" + nm + "</a></li>");
  });
    $('[data-toggle="popover"]').popover();
});
</script>

<link rel="shortcut icon" href="https://raw.githubusercontent.com/jverzani/CalculusWithJulia.jl/master/CwJ/misc/logo.png" type="image/x-icon" />

</head>


<body data-spy="scroll" >

  <header class="navbar navbar-expand-md navbar-dark bd-navbar">
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top navbar-nav">
    <div class="container-fluid">
      <a class="navbar-brand" href="https://juliahub.com/docs/CalculusWithJulia/">
      <img src="data:image/gif;base64,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"/>
      Calculus with Julia</a>

    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <ul class="nav navbar-nav navbar-right">
      <li class="nav-item dropdown dropstart">
	<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown"
	   role="button" data-bs-toggle="dropdown" aria-expanded="false">
            Jump to...
          </a>

        <ul class="dropdown-menu" aria-labelledby="navbarDropdown" role="menu" id="page_dropdown"></ul>
      </li>
    </ul>

    </div>
  </div>
</nav>

</header>
          <div class="title">
            
            
            
          </div>



<div class="container-fluid">
  <div class="span10 offset1">
    <h1>Implications of continuity</h1>


<p>Continuity for functions is a valued property which carries implications. In this section we discuss two: the intermediate value theorem and the extreme value theorem. These two theorems speak to some fundamental applications of calculus: finding zeros of a function and finding extrema of a function.</p>
<h2>Intermediate Value Theorem</h2>
<blockquote>
<p>The <em>intermediate value theorem</em>: If <span class="math">$f$</span> is continuous on <span class="math">$[a,b]$</span>  with, say, <span class="math">$f(a) < f(b)$</span>, then for any <span class="math">$y$</span> with <span class="math">$f(a) < y < f(b)$</span>  there exists a <span class="math">$c$</span> in <span class="math">$[a,b]$</span> with <span class="math">$f(c) = y$</span>.</p>
</blockquote>

<pre class="julia-error">
ERROR: UndefVarError: pyplot not defined
</pre>


<p>In the early years of calculus, the intermediate value theorem was intricately connected with the definition of continuity, now it is a consequence.</p>
<p>The basic proof starts with a set of points in <span class="math">$[a,b]$</span>: <span class="math">$C = \{x \text{ in } [a,b] \text{ with } f(x) \leq y\}$</span>. The set is not empty &#40;as <span class="math">$a$</span> is in <span class="math">$C$</span>&#41; so it <em>must</em> have a largest value, call it <span class="math">$c$</span> &#40;this requires the completeness property of the real numbers&#41;.  By continuity of <span class="math">$f$</span>, it can be shown that <span class="math">$\lim_{x \rightarrow c-} f(x) = f(c) \leq y$</span> and <span class="math">$\lim_{y \rightarrow c+}f(x) =f(c) \geq y$</span>, which forces <span class="math">$f(c) = y$</span>.</p>
<h3>Bolzano and the bisection method</h3>
<p>Suppose we have a continuous function <span class="math">$f(x)$</span> on <span class="math">$[a,b]$</span> with <span class="math">$f(a) < 0$</span> and <span class="math">$f(b) > 0$</span>. Then as <span class="math">$f(a) < 0 < f(b)$</span>, the intermediate value theorem guarantees the existence of a <span class="math">$c$</span> in <span class="math">$[a,b]$</span> with <span class="math">$f(c) = 0$</span>. This was a special case of the intermediate value theorem proved by Bolzano first. Such <span class="math">$c$</span> are called <em>zeros</em> of the function <span class="math">$f$</span>.</p>
<p>We use this fact when a building a &quot;sign chart&quot; of a polynomial function. Between any two consecutive real zeros the polynomial can not change sign. &#40;Why?&#41; So a &quot;test point&quot; can be used to determine the sign of the function over an entire interval.</p>
<p>Here, we use the Bolzano theorem to give an algorithm - the <em>bisection method</em> - to locate the value <span class="math">$c$</span> under the assumption <span class="math">$f$</span> is continous on <span class="math">$[a,b]$</span> and changes sign between <span class="math">$a$</span> and <span class="math">$b$</span>.</p>

<pre class="julia-error">
ERROR: UndefVarError: pyplot not defined
</pre>


<p>Call <span class="math">$[a,b]$</span> a <em>bracketing</em> interval if <span class="math">$f(a)$</span> and <span class="math">$f(b)$</span> have different signs. We remark that having different signs can be expressed mathematically as <span class="math">$f(a) \cdot f(b) < 0$</span>.</p>
<p>We can narrow down where a zero is in <span class="math">$[a,b]$</span> by following this recipe:</p>
<ul>
<li><p>Pick a midpoint of the interval, for concreteness <span class="math">$c = (a+b)/2$</span>.</p>
</li>
<li><p>If <span class="math">$f(c) = 0$</span> we are done, having found a zero in <span class="math">$[a,b]$</span>.</p>
</li>
<li><p>Otherwise if must be that either <span class="math">$f(a)\cdot f(c) < 0$</span> or <span class="math">$f(c) \cdot f(b) < 0$</span>. If <span class="math">$f(a) \cdot f(c) < 0$</span>, then let <span class="math">$b=c$</span> and repeat the above. Otherwise, let <span class="math">$a=c$</span> and repeat the above.</p>
</li>
</ul>
<p>At each step the bracketing interval is narrowed – indeed split in half as defined – or a zero is found.</p>
<p>For the real numbers this algorithm never stops unless a zero is found. A &quot;limiting&quot; process is used to say that if it doesn&#39;t stop, it will converge to some value.</p>
<p>However, using floating point numbers leads to differences from the real-number situation. In this case, due to the ultimate granularity of the approximation of floating point values to the real numbers, the bracketing interval eventually can&#39;t be subdivided, that is no <span class="math">$c$</span> is found over the floating point numbers with <span class="math">$a < c < b$</span>. So there is a natural stopping criteria: stop when there is an exact zero, or when the bracketing interval gets too small to subdivide.</p>
<p>We can write a relatively simple program to implement this algorithm:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>bisection</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'> </span><span class='hljl-k'>return</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'> </span><span class='hljl-k'>return</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'> </span><span class='hljl-nf'>error</span><span class='hljl-p'>(</span><span class='hljl-s'>&quot;[a,b] is not a bracketing interval&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>end</span><span class='hljl-t'>

  </span><span class='hljl-n'>tol</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>1e-14</span><span class='hljl-t'>  </span><span class='hljl-cs'># small number (but should depend on size of a, b)</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>/</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-oB'>/</span><span class='hljl-ni'>2</span><span class='hljl-t'>

  </span><span class='hljl-k'>while</span><span class='hljl-t'> </span><span class='hljl-nf'>abs</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-oB'>-</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>&gt;</span><span class='hljl-t'> </span><span class='hljl-n'>tol</span><span class='hljl-t'>
    </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'> </span><span class='hljl-k'>return</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>end</span><span class='hljl-t'>

    </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>&lt;</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'>
       </span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>c</span><span class='hljl-t'>
    </span><span class='hljl-k'>else</span><span class='hljl-t'>
       </span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>c</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>

    </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>/</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-oB'>/</span><span class='hljl-ni'>2</span><span class='hljl-t'>

  </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class="output">
bisection &#40;generic function with 1 method&#41;
</pre>


<p>This function uses a <code>while</code> loop to repeat the process of subdividing <span class="math">$[a,b]$</span>. A <code>while</code> loop will repeat until the condition is no longer <code>true</code>.  The above will stop for reasonably sized floating point values &#40;within <span class="math">$(-100, 100)$</span>, say&#41;, but, as written, ignores the fact that the gap between floating point values depends on their magnitude.</p>
<p>The value <span class="math">$c$</span> returned <em>need not</em> be an exact zero. Let&#39;s see:</p>


<pre class='hljl'>
<span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>bisection</span><span class='hljl-p'>(</span><span class='hljl-n'>sin</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>3</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
3.141592653589793
</pre>


<p>This value of <span class="math">$c$</span> is a floating-point approximation to <span class="math">$\pi$</span>, but is not <em>quite</em> a zero:</p>


<pre class='hljl'>
<span class='hljl-nf'>sin</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
1.2246467991473532e-16
</pre>


<p>&#40;Even <code>pi</code> itself is not a &quot;zero&quot; due to floating point issues.&#41;</p>
<h3>The <code>find_zero</code> function.</h3>
<p>The <code>Roots</code> package has a function <code>find_zero</code> that implements the bisection method when called as <code>find_zero&#40;f, a..b&#41;</code> where <span class="math">$[a,b]$</span> is a bracket. Its use is similar to <code>bisection</code> above. This package is loaded when <code>CalculusWithJulia</code> is. We illlustrate the usage of <code>find_zero</code> in the following:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>CalculusWithJulia</span><span class='hljl-t'>
</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Roots</span><span class='hljl-t'>
</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Plots</span><span class='hljl-t'>
</span><span class='hljl-n'>xstar</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>sin</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>3..4</span><span class='hljl-p'>)</span><span class='hljl-t'>   </span><span class='hljl-cs'># using interval notation a..b to specify the bracketing interval. Could use (a,b) as well</span>
</pre>


<pre class="julia-error">
ERROR: ArgumentError: Package CalculusWithJulia not found in current path:
- Run &#96;import Pkg; Pkg.add&#40;&quot;CalculusWithJulia&quot;&#41;&#96; to install the CalculusWithJulia package.

</pre>


<pre class="julia-error">
ERROR: UndefVarError: alert not defined
</pre>


<p>This function utilizes some facts about floating point values to guarantee that the answer will be an <em>exact</em> zero or a value where there is a sign change between the next bigger floating point or the next smaller, which means the sign at the next and previous floating point values is different:</p>


<pre class='hljl'>
<span class='hljl-nf'>sin</span><span class='hljl-p'>(</span><span class='hljl-n'>xstar</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-nf'>sign</span><span class='hljl-p'>(</span><span class='hljl-nf'>sin</span><span class='hljl-p'>(</span><span class='hljl-nf'>prevfloat</span><span class='hljl-p'>(</span><span class='hljl-n'>xstar</span><span class='hljl-p'>))),</span><span class='hljl-t'> </span><span class='hljl-nf'>sign</span><span class='hljl-p'>(</span><span class='hljl-nf'>sin</span><span class='hljl-p'>(</span><span class='hljl-nf'>nextfloat</span><span class='hljl-p'>(</span><span class='hljl-n'>xstar</span><span class='hljl-p'>)))</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: xstar not defined
</pre>


<h5>Example</h5>
<p>The polynomial <span class="math">$f(x) = x^5 - x + 1$</span> has a zero between <span class="math">$-2$</span> and <span class="math">$-1$</span>. Find it.</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>5</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
</span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>..</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span><span class='hljl-t'>  </span><span class='hljl-cs'># avoiding ..-1 which errors</span><span class='hljl-t'>
</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>))</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<p>We see, as before, that <span class="math">$f(c)$</span> is not quite <span class="math">$0$</span>. But you can check that <code>f&#40;prevfloat&#40;c&#41;&#41;</code> is negative, while <code>f&#40;c&#41;</code> is seen to be positive:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-nf'>sign</span><span class='hljl-p'>(</span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-nf'>prevfloat</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>))),</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-nf'>sin</span><span class='hljl-p'>(</span><span class='hljl-nf'>nextfloat</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-p'>)))</span>
</pre>


<pre class="output">
&#40;303.87809213169163, 1.0, 1.0000000000000002&#41;
</pre>


<h5>Example</h5>
<p>The function <span class="math">$f(x) = e^x - x^4$</span> has a zero between <span class="math">$5$</span> and <span class="math">$10$</span>, as this graph shows:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>exp</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>4</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>5</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>10</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>Find the zero numerically. The plot shows <span class="math">$f(5) < 0 < f(10)$</span>, so <span class="math">$[5,10]$</span> is a bracket. We thus have:</p>


<pre class='hljl'>
<span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>5..10</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h5>Example</h5>
<p>Find all real zeros of <span class="math">$f(x) = x^3 -x + 1$</span> using the bisection method.</p>
<p>We show next the symbolic values can be used with <code>find_zero</code>, should that be useful.</p>
<p>First, we produce a plot to identify a bracketing interval</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>SymPy</span><span class='hljl-t'>
</span><span class='hljl-nd'>@syms</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>3</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-ni'>3</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>3</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>It appears &#40;and a plot over <span class="math">$[0,1]$</span> verifies&#41; that there is one zero between <span class="math">$-2$</span> and <span class="math">$-1$</span>. It is found with:</p>


<pre class='hljl'>
<span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>3</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>..</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h5>Example</h5>
<p>The equation <span class="math">$\cos(x) = x$</span> has just one solution, as can be seen in this plot:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>cos</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-n'>pi</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>pi</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>g</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>Find it.</p>
<p>We see from the graph that it is clearly between <span class="math">$0$</span> and <span class="math">$2$</span>, so all we need is a function. &#40;We have two.&#41; The trick is to observe that solving <span class="math">$f(x) = g(x)$</span> is the same problem as solving for <span class="math">$x$</span> where <span class="math">$f(x) - g(x) = 0$</span>. So we define the difference and use that:</p>


<pre class='hljl'>
<span class='hljl-nf'>h</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>h</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>0..2</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h5>Example</h5>
<p>We wish to compare two trash collection plans</p>
<ul>
<li><p>Plan 1: You pay 47.49 plus 0.77 per bag.</p>
</li>
<li><p>Plan 2: You pay 30.00 plus 2.00 per bag.</p>
</li>
</ul>
<p>There are some cases where plan 1 is cheaper and some where plan 2 is. Categorize them.</p>
<p>Both plans are <em>linear models</em> and may be written in <em>slope-intercept</em> form:</p>


<pre class='hljl'>
<span class='hljl-nf'>plan1</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>47.49</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.77</span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-nf'>plan2</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>30.00</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.00</span><span class='hljl-n'>x</span>
</pre>


<pre class="output">
plan2 &#40;generic function with 1 method&#41;
</pre>


<p>Assuming this is a realistic problem and an average American household might produce 10-20 bags of trash a month &#40;yes, that seems too much&#33;&#41; we plot in that range:</p>


<pre class='hljl'>
<span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>plan1</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>10</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>20</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>plan2</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>We can see the intersection point is around 14 and that if a family generates between 0-14 bags of trash per month that plan 2 would be cheaper.</p>
<p>Let&#39;s get a numeric value, using a simple bracket and an anonymous function:</p>


<pre class='hljl'>
<span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-nf'>plan1</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-nf'>plan2</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-nfB'>10..20</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h5>Example, the flight of an arrow</h5>
<p>The flight of an arrow can be modeled using various functions, depending on assumptions. Suppose an arrow is launched in the air from a height of 0 feet above the ground at an angle of <span class="math">$\theta = \pi/4$</span>. With a suitable choice for the initial velocity, a model without wind resistance for the height of the arrow at a distance <span class="math">$x$</span> units away may be:</p>
<p class="math">\[
~
j(x) = \tan(\theta) x - (1/2) \cdot g(\frac{x}{v_0 \cos\theta})^2.
~
\]</p>
<p>In <code>julia</code> we have, taking <span class="math">$v_0=200$</span>:</p>


<pre class='hljl'>
<span class='hljl-nf'>j</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>;</span><span class='hljl-t'> </span><span class='hljl-n'>theta</span><span class='hljl-oB'>=</span><span class='hljl-n'>pi</span><span class='hljl-oB'>/</span><span class='hljl-ni'>4</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>g</span><span class='hljl-oB'>=</span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>v0</span><span class='hljl-oB'>=</span><span class='hljl-ni'>200</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>tan</span><span class='hljl-p'>(</span><span class='hljl-n'>theta</span><span class='hljl-p'>)</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-oB'>/</span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-oB'>*</span><span class='hljl-n'>g</span><span class='hljl-oB'>*</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>/</span><span class='hljl-p'>(</span><span class='hljl-n'>v0</span><span class='hljl-oB'>*</span><span class='hljl-nf'>cos</span><span class='hljl-p'>(</span><span class='hljl-n'>theta</span><span class='hljl-p'>)))</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span>
</pre>


<pre class="output">
j &#40;generic function with 1 method&#41;
</pre>


<p>With a velocity-dependent wind resistance given by <span class="math">$\gamma$</span>, again with some units, a similar equation can be constructed. It takes a different form:</p>
<p class="math">\[
~
y(x) = (\frac{g}{\gamma v_0 \cos(\theta)} + \tan(\theta)) \cdot x  +
      \frac{g}{\gamma^2}\log(\frac{v_0\cos(\theta) - \gamma x}{v_0\cos(\theta)})
~
\]</p>
<p>Again, <span class="math">$v_0$</span> is the initial velocity and is taken to be <span class="math">$200$</span> and <span class="math">$\gamma$</span> a resistance, which we take to be <span class="math">$1$</span>. With this, we have the following <code>julia</code> definition &#40;with a slight reworking of <span class="math">$\gamma$</span>&#41;:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>y</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>;</span><span class='hljl-t'> </span><span class='hljl-n'>theta</span><span class='hljl-oB'>=</span><span class='hljl-n'>pi</span><span class='hljl-oB'>/</span><span class='hljl-ni'>4</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>g</span><span class='hljl-oB'>=</span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>v0</span><span class='hljl-oB'>=</span><span class='hljl-ni'>200</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>gamma</span><span class='hljl-oB'>=</span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span><span class='hljl-t'>
	 </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>gamma</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-n'>v0</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>cos</span><span class='hljl-p'>(</span><span class='hljl-n'>theta</span><span class='hljl-p'>)</span><span class='hljl-t'>
	 </span><span class='hljl-p'>(</span><span class='hljl-n'>g</span><span class='hljl-oB'>/</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-nf'>tan</span><span class='hljl-p'>(</span><span class='hljl-n'>theta</span><span class='hljl-p'>))</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>g</span><span class='hljl-oB'>/</span><span class='hljl-n'>gamma</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>log</span><span class='hljl-p'>((</span><span class='hljl-n'>a</span><span class='hljl-oB'>-</span><span class='hljl-n'>gamma</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-oB'>/</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class="output">
y &#40;generic function with 1 method&#41;
</pre>


<p>For each model, we wish to find the value of <span class="math">$x$</span> after launching where the height is modeled to be 0. That is how far will the arrow travel before touching the ground?</p>
<p>For the model without wind resistance, we can graph the function easily enough. Let&#39;s guess the distance is no more than 500 feet:</p>


<pre class='hljl'>
<span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>j</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>500</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>Well, we haven&#39;t even seen the peak yet. Better to do a little spade work first. This is a quadratic function, so we can use <code>roots</code> from <code>SymPy</code> to find the roots:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>SymPy</span><span class='hljl-t'>
</span><span class='hljl-nd'>@syms</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-nf'>roots</span><span class='hljl-p'>(</span><span class='hljl-nf'>j</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>))</span>
</pre>


<pre class="output">
Dict&#123;Any, Any&#125; with 2 entries:
  0                &#61;&gt; 1
  1250.00000000000 &#61;&gt; 1
</pre>


<p>We see that <span class="math">$1250$</span> is the largest root. So we plot over this domain to visualize the flight:</p>


<pre class='hljl'>
<span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>j</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>1250</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>As for the model with wind resistance,  a quick plot over the same interval, <span class="math">$[0, 1250]$</span> yields:</p>


<pre class='hljl'>
<span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>1250</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>This graph eventually goes negative and then stops. This is due to the asymptote in model when <code>&#40;a - gamma^2*x&#41;/a</code> is zero. To plot the trajectory until it returns to <span class="math">$0$</span>, we need to identify the value of the zero. This model is non-linear and we don&#39;t have the simplicity of using <code>roots</code> to find out the answer, so we solve for when <span class="math">$a-\gamma^2 x$</span> is <span class="math">$0$</span>:</p>


<pre class='hljl'>
<span class='hljl-n'>gamma</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>200</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>cos</span><span class='hljl-p'>(</span><span class='hljl-n'>pi</span><span class='hljl-oB'>/</span><span class='hljl-ni'>4</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>/</span><span class='hljl-n'>gamma</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span>
</pre>


<pre class="output">
141.4213562373095
</pre>


<p>Note that the function is infinite at <code>b</code>:</p>


<pre class='hljl'>
<span class='hljl-nf'>y</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
-Inf
</pre>


<p>From the graph,  we can see the zero is around <code>b</code>. As <code>y&#40;b&#41;</code> is <code>-Inf</code> we can use the bracket <code>&#40;b/2,b&#41;</code></p>


<pre class='hljl'>
<span class='hljl-n'>x1</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-oB'>/</span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-oB'>..</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<p>The answer is approximately <span class="math">$140.7$</span></p>
<p>&#40;The bisection method only needs to know the sign of the function. Other bracketing methods would have issues with an endpoint with an infinite function value. To use them, some value between the zero and <code>b</code> would need to be used.&#41;</p>
<p>Finally, we plot both graphs at once to see that it was a very windy day indeed.</p>


<pre class='hljl'>
<span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>j</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>1250</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x1</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<h5>Example: bisection and non-continuity</h5>
<p>The Bolzano theorem assumes a continuous function <span class="math">$f$</span>, and when applicable, yields an algorithm to find a guaranteed zero.</p>
<p>However, the algorithm itself does not know that the function is continuous or not, only that the function changes sign. As such, it can produce answers that are not &quot;zeros&quot; when used with discontinuous functions.</p>
<p>In general a function over floating point values could be considered as a large table of mappings: each of the <span class="math">$2^{64}$</span> floating point values gets assigned a value. This is discrete mapping, there is nothing the computer sees related to continuity.</p>
<blockquote>
<p>The concept of continuity, if needed, must be verified by the user of the algorithm.</p>
</blockquote>
<p>We have seen this when plotting rational functions or functions with vertical asymptotes. The default algorithms just connect points with lines. The user must manage the discontinuity &#40;by assigning some values <code>NaN</code>, say&#41;; the algorithms used do not.</p>
<p>In this particular case, the bisection algorithm can still be fruitful even when the function is not continuous, as the algorithm will yield information about crossing values of <span class="math">$0$</span>, possibly at discontinuities. But the user of the algorithm must be aware that the answers are only guaranteed to be zeros of the function if the function is continuous and the algorithm did not check for that assumption.</p>
<p>As an example, let <span class="math">$f(x) = 1/x$</span>. Clearly the interval <span class="math">$[-1,1]$</span> is a &quot;bracketing&quot; interval as <span class="math">$f(x)$</span> changes sign between <span class="math">$a$</span> and <span class="math">$b$</span>. What does the algorithm yield:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>/</span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-n'>x0</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-nfB'>1..1</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<p>The function is not defined at the answer, but we do have the fact that just to the left of the answer &#40;<code>prevfloat</code>&#41; and just to the right of the answer &#40;<code>nextfloat</code>&#41; the function changes sign:</p>


<pre class='hljl'>
<span class='hljl-nf'>sign</span><span class='hljl-p'>(</span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-nf'>prevfloat</span><span class='hljl-p'>(</span><span class='hljl-n'>x0</span><span class='hljl-p'>))),</span><span class='hljl-t'> </span><span class='hljl-nf'>sign</span><span class='hljl-p'>(</span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-nf'>nextfloat</span><span class='hljl-p'>(</span><span class='hljl-n'>x0</span><span class='hljl-p'>)))</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: x0 not defined
</pre>


<p>So, the &quot;bisection method&quot; applied here finds a point where the function crosses <span class="math">$0$</span>, either by continuity or by jumping over the <span class="math">$0$</span>.  &#40;A <code>jump</code> discontinuity at <span class="math">$x=c$</span> is defined by the left and right limits of <span class="math">$f$</span> at <span class="math">$c$</span> existing but being unequal. The algorithm can find <span class="math">$c$</span> when this type of function jumps over <span class="math">$0$</span>.&#41;</p>
<h3>The <code>find_zeros</code> function</h3>
<p>The bisection method suggests a naive means to search for all zeros within an interval <span class="math">$(a, b)$</span>: split the interval into many small intervals and for each that is a bracketing interval find a zero. This simple description has three flaws: it might miss values where the function doesn&#39;t actually cross the <span class="math">$x$</span> axis; it might miss values where the function just dips to the other side; and it might miss multiple values in the same small interval.</p>
<p>Still, with some engineering, this can be a useful approach, save the caveats. This idea is implemented in the <code>find_zeros</code> function of the <code>Roots</code> package. The function is called via <code>find_zeros&#40;f, a.. b&#41;</code> but here the interval <span class="math">$[a,b]$</span> is not necessarily a bracketing interval.</p>
<p>To see, we have:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>cos</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-oB'>*</span><span class='hljl-n'>pi</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>find_zeros</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>0..1</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<p>Or for a polynomial:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>5</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>4</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>3</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
</span><span class='hljl-nf'>find_zeros</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-nfB'>10..10</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<p>&#40;Here <span class="math">$-10$</span> and <span class="math">$10$</span> were arbitrarily chosen. Cauchy&#39;s method could be used to be more systematic.&#41;</p>

<pre class="julia-error">
ERROR: UndefVarError: note not defined
</pre>


<h5>Example: Solving f&#40;x&#41; &#61; g&#40;x&#41;</h5>
<p>Use <code>find_zeros</code> to find when <span class="math">$e^x = x^5$</span> in the interval <span class="math">$[-20, 20]$</span>. Verify the answers.</p>
<p>To proceed with <code>find_zeros</code>, we define <span class="math">$f(x) = e^x - x^5$</span>, as <span class="math">$f(x) = 0$</span> precisely when <span class="math">$e^x = x^5$</span>. The zeros are then found with:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>exp</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>5</span><span class='hljl-t'>
</span><span class='hljl-n'>zs</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>find_zeros</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-nfB'>20..20</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<p>The output of <code>find_zeros</code> is a vector of values. To check that each value is an approximate zero can be done with the &quot;.&quot; &#40;broadcast&#41; syntax:</p>


<pre class='hljl'>
<span class='hljl-n'>f</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>zs</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: zs not defined
</pre>


<p>&#40;For a continuous function this should be the case that the values returned by <code>find_zeros</code> are approximate zeros. Bear in mind that if <span class="math">$f$</span> is not continous the algorithm might find jumping points that are not zeros and may not even be in the domain of the function.&#41;</p>
<h3>An alternate interface to <code>find_zero</code></h3>
<p>The <code>find_zero</code> function in the <code>Roots</code> package is an interface to one of several methods. For now we focus on the <em>bracketing</em> methods, later we will see others. Bracketing methods, among others,  include <code>Roots.Bisection&#40;&#41;</code>, the basic bisection method though with a different sense of &quot;middle&quot; than <span class="math">$(a+b)/2$</span> and used by default above; <code>Roots.A42&#40;&#41;</code>, which will typically converge much faster than simple bisection; <code>Roots.Brent&#40;&#41;</code> for the classic method of Brent, and <code>FalsePosition&#40;&#41;</code> for a family of <em>regula falsi</em> methods. These can all be used by specifying the method in a call to <code>find_zero</code>.</p>
<p>Alternatively, <code>Roots</code> implements the <code>CommonSolve</code> interface popularized by its use in the <code>DifferentialEquations.jl</code> ecosystem, a wildly successful area for <code>Julia</code>. The basic setup is two steps: setup a &quot;problem,&quot; solve the problem.</p>
<p>To set up a problem, we call <code>ZeroProblem</code> with the function and an initial interval, as in:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>5</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
</span><span class='hljl-n'>prob</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>ZeroProblem</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-ni'>2</span><span class='hljl-p'>))</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: ZeroProblem not defined
</pre>


<p>Then we can &quot;solve&quot; this problem with <code>solve</code>. For example:</p>


<pre class='hljl'>
<span class='hljl-nf'>solve</span><span class='hljl-p'>(</span><span class='hljl-n'>prob</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>Roots</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Bisection</span><span class='hljl-p'>()),</span><span class='hljl-t'> </span><span class='hljl-nf'>solve</span><span class='hljl-p'>(</span><span class='hljl-n'>prob</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>Roots</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Brent</span><span class='hljl-p'>()),</span><span class='hljl-t'> </span><span class='hljl-nf'>solve</span><span class='hljl-p'>(</span><span class='hljl-n'>prob</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>Roots</span><span class='hljl-oB'>.</span><span class='hljl-nf'>A42</span><span class='hljl-p'>())</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: Roots not defined
</pre>


<p>Though the answers are identical, the methods employed were not.</p>
<p>Behind the scenes, <code>solve</code> <em>initializes</em> a iterator and then iterates it to completion. This can be accessed through the <code>init</code> method. For example, we can see the steps along the way  of the <code>FalsePosition</code> method for this problem:</p>


<pre class='hljl'>
<span class='hljl-n'>o</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>init</span><span class='hljl-p'>(</span><span class='hljl-n'>prob</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nf'>FalsePosition</span><span class='hljl-p'>())</span><span class='hljl-t'>
</span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>o</span><span class='hljl-t'>
  </span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: FalsePosition not defined
</pre>


<p>The command <code>find_zero&#40;f, 1..2, FalsePosition&#40;&#41;, verbose&#61;true&#41;</code> would give more detail on the algorithm in a standard format, but this method may be of interest, as it allows the combination of different models.</p>
<h2>Extreme value theorem</h2>
<p>The Extreme Value Theorem is another consequence of continuity.</p>
<p>To discuss the extreme value theorem, we define an <em>absolute maximum</em>.</p>
<blockquote>
<p>The absolute maximum of <span class="math">$f(x)$</span> over an interval <span class="math">$I$</span> is the value <span class="math">$f(c)$</span>, <span class="math">$c$</span> in <span class="math">$I$</span>, where <span class="math">$f(x) \leq f(c)$</span> for any <span class="math">$x$</span> in <span class="math">$I$</span>.</p>
<p>Similarly, an <em>absolute minimum</em> of <span class="math">$f(x)$</span> over an interval <span class="math">$I$</span> can be defined by a value <span class="math">$f(c)$</span> where <span class="math">$c$</span> is in <span class="math">$I$</span> <em>and</em> <span class="math">$f(c) \leq f(x)$</span> for any <span class="math">$x$</span> in <span class="math">$I$</span>.</p>
</blockquote>
<p>Related but different is the concept of a relative of <em>local extrema</em>:</p>
<blockquote>
<p>A local maxima for <span class="math">$f$</span> is a value <span class="math">$f(c)$</span> where <span class="math">$c$</span> is in <strong>some</strong> <em>open</em> interval <span class="math">$I=(a,b)$</span>, <span class="math">$I$</span> in the domain of <span class="math">$f$</span>, and <span class="math">$f(c)$</span> is an absolute maxima for <span class="math">$f$</span> over <span class="math">$I$</span>. Similarly, an local minima for <span class="math">$f$</span> is a value <span class="math">$f(c)$</span> where <span class="math">$c$</span> is in <strong>some</strong> <em>open</em> interval <span class="math">$I=(a,b)$</span>, <span class="math">$I$</span> in the domain of <span class="math">$f$</span>, and <span class="math">$f(x)$</span> is an absolute minima for <span class="math">$f$</span> over <span class="math">$I$</span>.</p>
</blockquote>
<p>The term <em>local extrema</em> is used to describe either a local maximum or local minimum.</p>
<p>The key point, is the extrema are values in the <em>range</em> that are realized by some value in the domain &#40;possibly more than one.&#41;</p>
<p>This chart of the <a href="http://hardrock100.com/">Hardrock 100</a> illustrates the two concepts.</p>

<pre class="julia-error">
ERROR: UndefVarError: ImageFile not defined
</pre>


<p>The extreme value theorem discusses an assumption that ensures such absolute maximum and absolute minimum values exist.</p>
<blockquote>
<p>The <em>extreme value theorem</em>: If <span class="math">$f(x)$</span> is continuous over a closed  interval <span class="math">$[a,b]$</span> then <span class="math">$f$</span> has an absolute maximum and an absolute  minimum over <span class="math">$[a,b]$</span>.</p>
</blockquote>
<p>&#40;By continuous over <span class="math">$[a,b]$</span> we mean continuous on <span class="math">$(a,b)$</span> and right continuous at <span class="math">$a$</span> and left continuous at <span class="math">$b$</span>.&#41;</p>
<p>The assumption that <span class="math">$[a,b]$</span> includes its endpoints &#40;it is closed&#41;  is crucial to make a guarantee. There are functions which are continuous on open intervals for which this result is not true. For example, <span class="math">$f(x) = 1/x$</span> on <span class="math">$(0,1)$</span>. This function will have no smallest value or largest value, as defined above.</p>
<p>The extreme value theorem is an important theoretical tool for investigating maxima and minima of functions.</p>
<h5>Example</h5>
<p>The function <span class="math">$f(x) = \sqrt{1-x^2}$</span> is continuous on the interval <span class="math">$[-1,1]$</span> &#40;in the sense above&#41;. It then has an absolute maximum, we can see to be <span class="math">$1$</span> occurring at an interior point <span class="math">$0$</span>. The absolute minimum is <span class="math">$0$</span>, it occurs at each endpoint.</p>
<h5>Example</h5>
<p>The function <span class="math">$f(x) = x \cdot e^{-x}$</span> on the closed interval <span class="math">$[0, 5]$</span> is continuous. Hence it has an absolute maximum, which a graph shows to be <span class="math">$0.4$</span>. It has an absolute minimum, clearly the value <span class="math">$0$</span> occurring at the endpoint.</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>exp</span><span class='hljl-p'>(</span><span class='hljl-oB'>-</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<h5>Example</h5>
<p>The tangent function does not have a <em>guarantee</em> of absolute maximum or minimum over <span class="math">$(-\pi/2, \pi/2)$</span>, as it is not <em>continuous</em> at the endpoints. In fact, it doesn&#39;t have either extrema - it has vertical asymptotes at each endpoint of this interval.</p>
<h5>Example</h5>
<p>The function <span class="math">$f(x) = x^{2/3}$</span> over the interval <span class="math">$[-2,2]$</span> has cusp at <span class="math">$0$</span>. However, it is continuous on this closed interval, so must have an absolute maximum and absolute minimum. They can be seen from the graph to occur at the endpoints and the cusp at <span class="math">$x=0$</span>, respectively:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-oB'>^</span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-oB'>/</span><span class='hljl-ni'>3</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>&#40;The definition <code>x^&#40;2/3&#41;</code> fails, can you see why?&#41;</p>
<h5>Example</h5>
<p>A New York Times <a href="https://www.nytimes.com/2016/07/30/world/europe/norway-considers-a-birthday-gift-for-finland-the-peak-of-an-arctic-mountain.html">article</a> discusses an idea of Norway moving its border some 490 feet north and 650 feet east in order to have the peak of Mount Halti be the highest point in Finland, as currently it would be on the boundary. Mathematically this hints at a higher dimensional version of the extreme value theorem.</p>
<h2>Continuity and closed and open sets</h2>
<p>We comment on two implications of continuity that can be generalized to more general settings.</p>
<p>The two intervals <span class="math">$(a,b)$</span> and <span class="math">$[a,b]$</span> differ as the latter includes the endpoints. The extreme value theorem shows this distinction can make a big difference in what can be said regarding <em>images</em> of such interval.</p>
<p>In particular, if <span class="math">$f$</span> is continuous and <span class="math">$I = [a,b]$</span> with <span class="math">$a$</span> and <span class="math">$b$</span> finite &#40;<span class="math">$I$</span> is <em>closed</em> and bounded&#41; then the <em>image</em> of <span class="math">$I$</span> sometimes denoted <span class="math">$f(I) = \{y: y=f(x) \text{ for } x \in I\}$</span> has the property that it will be an interval and will include its endpoints &#40;also closed and bounded&#41;.</p>
<p>That <span class="math">$f(I)$</span> is an interval is a consequence of the Intermediate Value Theorem. That <span class="math">$f(I)$</span> contains its endpoints is the Extreme Value Theorem.</p>
<p>On the real line, sets that are closed and bounded are &quot;compact,&quot; a term that generalizes to other settings.</p>
<blockquote>
<p>Continuity implies that the <em>image</em> of a compact set is compact.</p>
</blockquote>
<p>Now let <span class="math">$(c,d)$</span> be an <em>open</em> interval in the range of <span class="math">$f$</span>. An open interval is an open set. On the real line, an open set is one where each point in the set, <span class="math">$a$</span>, has some <span class="math">$\delta$</span> such that if <span class="math">$|b-a| < \delta$</span> then <span class="math">$b$</span> is also in the set.</p>
<blockquote>
<p>Continuity implies that the <em>preimage</em> of an open set is an open set.</p>
</blockquote>
<p>The <em>preimage</em> of an open set, <span class="math">$I$</span>, is <span class="math">$\{a: f(a) \in I\}$</span>. &#40;All <span class="math">$a$</span> with an image in <span class="math">$I$</span>.&#41; Taking some pair <span class="math">$(a,y)$</span> with <span class="math">$y$</span> in <span class="math">$I$</span> and <span class="math">$a$</span> in the preimage as <span class="math">$f(a)=y$</span>. Let <span class="math">$\epsilon$</span> be such that <span class="math">$|x-y| < \epsilon$</span> implies <span class="math">$x$</span> is in <span class="math">$I$</span>. Then as <span class="math">$f$</span> is continuous at <span class="math">$a$</span>, given <span class="math">$\epsilon$</span> there is a <span class="math">$\delta$</span> such that <span class="math">$|b-a| <\delta$</span> implies <span class="math">$|f(b) - f(a)| < \epsilon$</span> or <span class="math">$|f(b)-y| < \epsilon$</span> which means that <span class="math">$f(b)$</span> is in the <span class="math">$I$</span> so <span class="math">$b$</span> is in the preimage, implying the preimage is an open set.</p>
<h2>Questions</h2>
<h6>Question</h6>
<p>In the following illustration, what is the value of the zero of <span class="math">$f$</span>?</p>

<pre class="julia-error">
ERROR: UndefVarError: CalculusWithJulia not defined
</pre>


<pre class="julia-error">
ERROR: UndefVarError: numericq not defined
</pre>


<h6>Question</h6>
<p>There is negative zero in the interval <span class="math">$[-10, 0]$</span> for the function <span class="math">$f(x) = e^x - x^4$</span>. Find its value numerically:</p>

<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h6>Question</h6>
<p>There is  zero in the interval <span class="math">$[0, 5]$</span> for the function <span class="math">$f(x) = e^x - x^4$</span>. Find its value numerically:</p>

<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h6>Question</h6>
<p>Let <span class="math">$f(x) = x^2 - 10 \cdot x \cdot \log(x)$</span>. This function has two zeros on the positive <span class="math">$x$</span> axis. You are asked to find the largest &#40;graph and bracket...&#41;.</p>

<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h6>Question</h6>
<p>The <code>airyai</code> function has infinitely many negative roots, as the function oscillates when <span class="math">$x < 0$</span> and <em>no</em> positive roots. Find the <em>second largest root</em> using the graph to bracket the answer, and then solve.</p>


<pre class='hljl'>
<span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>airyai</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-ni'>10</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>10</span><span class='hljl-p'>)</span><span class='hljl-t'>   </span><span class='hljl-cs'># `airyai` loaded in `SpecialFunctions` by `CalculusWithJulia`</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<p>The second largest root is:</p>

<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h6>Question</h6>
<p>&#40;From <a href="http://ocw.mit.edu/ans7870/resources/Strang/Edited/Calculus/Calculus.pdf">Strang</a>, p. 37&#41;</p>
<p>Certainly <span class="math">$x^3$</span> equals <span class="math">$3^x$</span> at <span class="math">$x=3$</span>. Find the largest value for which <span class="math">$x^3 = 3x$</span>.</p>

<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<p>Compare <span class="math">$x^2$</span> and <span class="math">$2^x$</span>. They meet at <span class="math">$2$</span>, where do the meet again?</p>

<pre class="julia-error">
ERROR: UndefVarError: radioq not defined
</pre>


<p>Just by graphing, find a number in <span class="math">$b$</span> with <span class="math">$2 < b < 3$</span> where for values less than <span class="math">$b$</span> there is a zero beyond <span class="math">$b$</span> of <span class="math">$b^x - x^b$</span> and for values more than <span class="math">$b$</span> there isn&#39;t.</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:3
</pre>


<h6>Question: What goes up must come down...</h6>

<pre class="julia-error">
ERROR: UndefVarError: ImageFile not defined
</pre>


<p>In 1638, according to Amir D. <a href="http://books.google.com/books?id&#61;kvGt2OlUnQ4C&amp;pg&#61;PA28&amp;lpg&#61;PA28&amp;dq&#61;mersenne&#43;cannon&#43;ball&#43;tests&amp;source&#61;bl&amp;ots&#61;wEUd7e0jFk&amp;sig&#61;LpFuPoUvODzJdaoug4CJsIGZZHw&amp;hl&#61;en&amp;sa&#61;X&amp;ei&#61;KUGcU6OAKJCfyASnioCoBA&amp;ved&#61;0CCEQ6AEwAA#v&#61;onepage&amp;q&#61;mersenne&#37;20cannon&#37;20ball&#37;20tests&amp;f&#61;false">Aczel</a>, an experiment was performed in the French Countryside. A monk, Marin Mersenne, launched a cannonball straight up into the air in an attempt to help Descartes prove facts about the rotation of the earth. Though the experiment was not successful, Mersenne later observed that the time for the cannonball to go up was greater than the time to come down. <a href="http://www.maa.org/publications/periodicals/american-mathematical-monthly/american-mathematical-monthly-contents-junejuly-2014">&quot;Vertical Projection in a Resisting Medium: Reflections on Observations of Mersenne&quot;.</a></p>
<p>This isn&#39;t the case for simple ballistic motion where the time to go up is equal to the time to come down. We can &quot;prove&quot; this numerically. For simple ballistic motion:</p>
<p class="math">\[
~
f(t) = -\frac{1}{2} \cdot 32 t^2 + v_0t.
~
\]</p>
<p>The time to go up and down are found by the two zeros of this function. The peak time is related to a zero of a function given by <code>f&#39;</code>, which for now we&#39;ll take as a mystery operation, but later will be known as the derivative. &#40;The notation assumes <code>CalculusWithJulia</code> has been loaded.&#41;</p>
<p>Let <span class="math">$v_0= 390$</span>. The three times in question can be found from the zeros of <code>f</code> and <code>f&#39;</code>. What are they?</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:2
</pre>


<h6>Question What goes up must come down... &#40;again&#41;</h6>
<p>For simple ballistic motion you find that the time to go up is the time to come down. For motion within a resistant medium, such as air, this isn&#39;t the case. Suppose a model for the height as a function of time is given by</p>
<p class="math">\[
~
h(t) = (\frac{g}{\gamma^2} + \frac{v_0}{\gamma})(1 - e^{-\gamma t}) - \frac{gt}{\gamma}
~
\]</p>
<p>&#40;<a href="http://www.researchgate.net/publication/230963032_On_the_trajectories_of_projectiles_depicted_in_early_ballistic_woodcuts">From &quot;On the trajectories of projectiles depicted in early ballistic Woodcuts&quot;</a>&#41;</p>
<p>Here <span class="math">$g=32$</span>, again we take <span class="math">$v_0=390$</span>, and <span class="math">$\gamma$</span> is a drag coefficient that we will take to be <span class="math">$1$</span>.  This is valid when <span class="math">$h(t) \geq 0$</span>.  In <code>Julia</code>, rather than hard-code the parameter values, for added flexibility we can pass them in as keyword arguments:</p>


<pre class='hljl'>
<span class='hljl-nf'>h</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>;</span><span class='hljl-t'> </span><span class='hljl-n'>g</span><span class='hljl-oB'>=</span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>v0</span><span class='hljl-oB'>=</span><span class='hljl-ni'>390</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>gamma</span><span class='hljl-oB'>=</span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>g</span><span class='hljl-oB'>/</span><span class='hljl-n'>gamma</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>v0</span><span class='hljl-oB'>/</span><span class='hljl-n'>gamma</span><span class='hljl-p'>)</span><span class='hljl-oB'>*</span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-nf'>exp</span><span class='hljl-p'>(</span><span class='hljl-oB'>-</span><span class='hljl-n'>gamma</span><span class='hljl-oB'>*</span><span class='hljl-n'>t</span><span class='hljl-p'>))</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>g</span><span class='hljl-oB'>*</span><span class='hljl-n'>t</span><span class='hljl-oB'>/</span><span class='hljl-n'>gamma</span>
</pre>


<pre class="output">
h &#40;generic function with 1 method&#41;
</pre>


<p>Now find the three times: <span class="math">$t_0$</span>, the starting time; <span class="math">$t_a$</span>, the time at the apex of the flight; and <span class="math">$t_f$</span>, the time the object returns to the ground.</p>

<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h6>Question</h6>
<p>Part of the proof of the intermediate value theorem rests on knowing what the limit is of <span class="math">$f(x)$</span> when <span class="math">$f(x) > y$</span> for all <span class="math">$x$</span>. What can we say about <span class="math">$L$</span> supposing <span class="math">$L = \lim_{x \rightarrow c+}f(x)$</span> under  this assumption on <span class="math">$f$</span>?</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:2
</pre>


<h6>Question</h6>
<p>The extreme value theorem has two assumptions: a continuous function and a <em>closed</em> interval. Which of the following examples fails to satisfy the consequence of the  extreme value theorem because the interval is not closed? &#40;The consequence - the existence of an absolute maximum and minimum - can happen even if the theorem does not apply.&#41;</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:3
</pre>


<h6>Question</h6>
<p>The extreme value theorem has two assumptions: a continuous function and a <em>closed</em> interval. Which of the following examples fails to satisfy the consequence of the  extreme value theorem because the function is not continuous?</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:3
</pre>


<h6>Question</h6>
<p>The extreme value theorem has two assumptions: a continuous function and a <em>closed</em> interval. Which of the following examples fails to satisfy the consequence of the  extreme value theorem because the function is not continuous?</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:3
</pre>


<h6>Question</h6>
<p>The function <span class="math">$f(x) = x^3 - x$</span> is continuous over the interval <span class="math">$I=[-2,2]$</span>. Find a value <span class="math">$c$</span> for which <span class="math">$M=f(c)$</span> is an absolute maximum over <span class="math">$I$</span>.</p>

<pre class="julia-error">
ERROR: UndefVarError: numericq not defined
</pre>


<h6>Question</h6>
<p>The function <span class="math">$f(x) = x^3 - x$</span> is continuous over the interval <span class="math">$I=[-1,1]$</span>. Find a value <span class="math">$c$</span> for which <span class="math">$M=f(c)$</span> is an absolute maximum over <span class="math">$I$</span>.</p>

<pre class="julia-error">
ERROR: UndefVarError: numericq not defined
</pre>


<h6>Question</h6>
<p>Consider the continuous function <span class="math">$f(x) = \sin(x)$</span> over the closed interval <span class="math">$I=[0, 10\pi]$</span>. Which of these is true?</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:3
</pre>


<h6>Question</h6>
<p>Consider the continuous function <span class="math">$f(x) = \sin(x)$</span> over the closed interval <span class="math">$I=[0, 10\pi]$</span>. Which of these is true?</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:3
</pre>


<h6>Question</h6>
<p>The extreme value theorem says that on a closed interval a continuous function has an extreme value <span class="math">$M=f(c)$</span> for some <span class="math">$c$</span>. Does it also say that <span class="math">$c$</span> is unique? Which of these examples might help you answer this?</p>

<pre class="julia-error">
ERROR: LoadError: UndefVarError: @L_str not defined
in expression starting at /Users/verzani/julia/CalculusWithJulia/CwJ/limits/intermediate_value_theorem.jmd:3
</pre>


<h5>Question</h5>
<p>The zeros of the equation <span class="math">$\cos(x) \cdot \cosh(x) = 1$</span> are related to vibrations of rods. Using <code>find_zeros</code>, what is the largest zero in the interval <span class="math">$[0, 6\pi]$</span>?</p>

<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<h5>Question</h5>
<p>A parametric equation is specified by a parameterization <span class="math">$(f(t), g(t)), a \leq t \leq b$</span>. The parameterization will be continuous if and only if each function is continuous.</p>
<p>Suppose <span class="math">$k_x$</span> and <span class="math">$k_y$</span> are positive integers and <span class="math">$a, b$</span> are positive numbers, will the <a href="https://en.wikipedia.org/wiki/Parametric_equation#Lissajous_Curve">Lissajous</a> curve given by <span class="math">$(a\cos(k_x t), b\sin(k_y t))$</span> be continuous?</p>

<pre class="julia-error">
ERROR: UndefVarError: yesnoq not defined
</pre>


<p>Here is a sample graph for <span class="math">$a=1, b=2, k_x=3, k_y=4$</span>:</p>


<pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
</span><span class='hljl-n'>k_x</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>k_y</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>3</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>cos</span><span class='hljl-p'>(</span><span class='hljl-n'>k_x</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-n'>t</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-n'>t</span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>sin</span><span class='hljl-p'>(</span><span class='hljl-n'>k_y</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-n'>t</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-n'>pi</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: plot not defined
</pre>


<hr />
<h2>Using <code>IntervalRootFinding</code> to identify all zeros in an interval</h2>
<p>The <code>IntervalRootFinding</code> package provides a more <em>rigorous</em> alternative to <code>find_zeros</code>. This packages leverages the interval arithmetic features of <code>IntervalArithmetic</code>. The <code>IntervalRootFinding</code> package provides a function <code>roots</code>, with usage similar to <code>find_zeros</code>. Intervals are specified with the notation <code>a..b</code>. In the following, we <em>qualify</em> <code>roots</code> to not conflict with the <code>roots</code> function from <code>SymPy</code>, which has already been loaded:</p>


<pre class='hljl'>
<span class='hljl-k'>import</span><span class='hljl-t'> </span><span class='hljl-n'>IntervalArithmetic</span><span class='hljl-t'>
</span><span class='hljl-k'>import</span><span class='hljl-t'> </span><span class='hljl-n'>IntervalRootFinding</span><span class='hljl-t'>
</span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sin</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.1</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
</span><span class='hljl-n'>J</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>IntervalArithmetic</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Interval</span><span class='hljl-p'>(</span><span class='hljl-oB'>-</span><span class='hljl-ni'>10</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>10</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-cs'># cumbersome -10..10; needed here: .. means something in CalculusWithJulia</span><span class='hljl-t'>
</span><span class='hljl-n'>rts</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>IntervalRootFinding</span><span class='hljl-oB'>.</span><span class='hljl-nf'>roots</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>J</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
4-element Vector&#123;IntervalRootFinding.Root&#123;IntervalArithmetic.Interval&#123;Float64&#125;&#125;&#125;:
 Root&#40;&#91;3.14959, 3.1496&#93;, :unique&#41;
 Root&#40;&#91;-4.42654, -4.42653&#93;, :unique&#41;
 Root&#40;&#91;-3.10682, -3.10681&#93;, :unique&#41;
 Root&#40;&#91;-1.08205, -1.08204&#93;, :unique&#41;
</pre>


<p>The &quot;zeros&quot; are returned with an enclosing interval and a flag, which for the above indicates a unique zero in the interval.</p>
<p>The intervals with a unique answer can be filtered and refined with a construct like the following:</p>


<pre class='hljl'>
<span class='hljl-p'>[</span><span class='hljl-nf'>find_zero</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>IntervalArithmetic</span><span class='hljl-oB'>.</span><span class='hljl-nf'>interval</span><span class='hljl-p'>(</span><span class='hljl-n'>I</span><span class='hljl-p'>)</span><span class='hljl-oB'>.</span><span class='hljl-n'>lo</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>IntervalArithmetic</span><span class='hljl-oB'>.</span><span class='hljl-nf'>interval</span><span class='hljl-p'>(</span><span class='hljl-n'>I</span><span class='hljl-p'>)</span><span class='hljl-oB'>.</span><span class='hljl-n'>hi</span><span class='hljl-p'>))</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>I</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>rts</span><span class='hljl-t'> </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-n'>I</span><span class='hljl-oB'>.</span><span class='hljl-n'>status</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-sc'>:unique</span><span class='hljl-p'>]</span>
</pre>


<pre class="output">
4-element Vector&#123;Float64&#125;:
  3.1495967624505226
 -4.426534982071949
 -3.1068165552293254
 -1.082042132760718
</pre>


<p>The midpoint of the returned interval can be found by composing the <code>mid</code> function with the <code>interval</code> function of the package:</p>


<pre class='hljl'>
<span class='hljl-p'>[(</span><span class='hljl-n'>IntervalArithmetic</span><span class='hljl-oB'>.</span><span class='hljl-n'>mid</span><span class='hljl-t'> </span><span class='hljl-oB'>∘</span><span class='hljl-t'> </span><span class='hljl-n'>IntervalArithmetic</span><span class='hljl-oB'>.</span><span class='hljl-n'>interval</span><span class='hljl-p'>)(</span><span class='hljl-n'>I</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>I</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>rts</span><span class='hljl-t'> </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-n'>I</span><span class='hljl-oB'>.</span><span class='hljl-n'>status</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-sc'>:unique</span><span class='hljl-p'>]</span>
</pre>


<pre class="output">
4-element Vector&#123;Float64&#125;:
  3.149596762458518
 -4.426534982087748
 -3.106816555229298
 -1.0820421327607175
</pre>


<p>For some problems, <code>find_zeros</code> is more direct, as with this one:</p>


<pre class='hljl'>
<span class='hljl-nf'>find_zeros</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-nfB'>10..10</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: UndefVarError: .. not defined
</pre>


<p>Which can be useful if there is some prior understanding of the zeros expected to be found. However, <code>IntervalRootFinding</code> is more efficient computationally and <em>offers a guarantee</em> on the values found.</p>
<p>For functions where roots are not &quot;unique&quot; a different output may appear:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>*</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>-</span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-t'>
</span><span class='hljl-n'>rts</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>IntervalRootFinding</span><span class='hljl-oB'>.</span><span class='hljl-nf'>roots</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>J</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
2-element Vector&#123;IntervalRootFinding.Root&#123;IntervalArithmetic.Interval&#123;Float64&#125;&#125;&#125;:
 Root&#40;&#91;0.999999, 1.00001&#93;, :unknown&#41;
 Root&#40;&#91;-1.59608e-12, 1.38991e-12&#93;, :unique&#41;
</pre>


<p>The interval labeled <code>:unknown</code> contains a <code>0</code>, but it can&#39;t be proved by <code>roots</code>.</p>
<p>Interval arithmetic finds <strong>rigorous</strong> <strong>bounds</strong> on the range of <code>f</code> values over a closed interval <code>a..b</code> &#40;the range is <code>f&#40;a..b&#41;</code>&#41;.  &quot;Rigorous&quot; means the bounds are truthful and account for possible floating point issues. &quot;Bounds&quot; means the answer lies within, but the bound need not be the answer.</p>
<p>This allows one – for some functions – to answer affirmatively questions like:</p>
<ul>
<li><p>Is the function <em>always</em> positive on <code>a..b</code>? Negative? This can be done by checking if <code>0</code> is in the bound given by <code>f&#40;a..b&#41;</code>. If it isn&#39;t then one of the two characterizations is true.</p>
</li>
<li><p>Is the function <em>strictly increasing</em> on <code>a..b</code>? Strictly decreasing? These questions can be answered using the &#40;upcoming&#41; <a href="../derivatives/derivatives.html">derivative</a>. If the derivative is positive on <code>a..b</code> then <code>f</code> is strictly increasing, if negative on <code>a..b</code> then <code>f</code> is strictly decreasing. Finding the derivative can be done within the <code>IntervalArithmetic</code> framework using <a href="../derivatives/numeric_derivatives.html">automatic differentiation</a>, a blackbox operation  denoted <code>f&#39;</code> below.</p>
</li>
</ul>
<p>Combined, for some functions and some intervals these two questions can be answered affirmatively:</p>
<ul>
<li><p>the interval does not contain a zero &#40;<code>0 &#33;in f&#40;a..b&#41;</code>&#41;</p>
</li>
<li><p>over the interval, the function crosses the <code>x</code> axis <em>once</em> &#40;<code>f&#40;a..a&#41;</code> and <code>f&#40;b..b&#41;</code> are one positive and one negative <em>and</em> <code>f</code> is strictly monotone, or <code>0 &#33;in f&#39;&#40;a..b&#41;</code>&#41;</p>
</li>
</ul>
<p>This allows the following &#40;simplified&#41; bisection-like algorithm to be used:</p>
<ul>
<li><p>consider an interval <code>a..b</code></p>
</li>
<li><p>if the function is <em>always</em> positive or negative, it can be discarded as no zero can be in the interval</p>
</li>
<li><p>if the function crosses the <code>x</code> axis <em>once</em> over this interval <strong>then</strong> there is a &quot;unique&quot; zero in the interval and the interval can be marked so and set aside</p>
</li>
<li><p>if neither of the above  <em>and</em> <code>a..b</code> is not too small already, then <em>sub-divide</em> the interval and repeat the above with <em>both</em> smaller intervals</p>
</li>
<li><p>if <code>a..b</code> is too small, stop and mark it as &quot;unknown&quot;</p>
</li>
</ul>
<p>When terminated there will be intervals with unique zeros flagged and smaller intervals with an unknown status.</p>
<p>Compared to the <em>bisection</em> algorithm – which only knows for some intervals if that interval has one or more crossings – this algorithm gives a more rigorous means to get all the zeros in <code>a..b</code>.</p>
<p>For a last example of the value of this package, this function, which appeared in our discussion on limits, is <em>positive</em> for <strong>every</strong> floating point number, but has two zeros snuck in at values within the floating point neighbors of <span class="math">$15/11$</span></p>


<pre class='hljl'>
<span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-nf'>log</span><span class='hljl-p'>(</span><span class='hljl-nf'>abs</span><span class='hljl-p'>(</span><span class='hljl-t'> </span><span class='hljl-ni'>11</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-oB'>-</span><span class='hljl-ni'>15</span><span class='hljl-t'> </span><span class='hljl-p'>))</span><span class='hljl-oB'>/</span><span class='hljl-ni'>99</span>
</pre>


<pre class="output">
g &#40;generic function with 1 method&#41;
</pre>


<p>The <code>find_zeros</code> function will fail on identifying any potential zeros of this function. Even the basic call of <code>roots</code> will fail, due to it relying on some smoothness of <code>f</code>. However, explicitly asking for <code>Bisection</code> shows the <em>potential</em> for one or more zeros near <span class="math">$15/11$</span>:</p>


<pre class='hljl'>
<span class='hljl-n'>J</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'>
</span><span class='hljl-n'>IntervalRootFinding</span><span class='hljl-oB'>.</span><span class='hljl-nf'>roots</span><span class='hljl-p'>(</span><span class='hljl-n'>g</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>J</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>IntervalRootFinding</span><span class='hljl-oB'>.</span><span class='hljl-n'>Bisection</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
1-element Vector&#123;IntervalRootFinding.Root&#123;IntervalArithmetic.Interval&#123;Float64&#125;&#125;&#125;:
 Root&#40;&#91;1.36363, 1.36364&#93;, :unknown&#41;
</pre>


<p>&#40;The basic algorithm above can be sped up using a variant of <a href="../derivatives/newton_method.html">Newton&#39;s</a> method, this variant assumes some &quot;smoothness&quot; in the function <code>f</code>, whereas this <code>f</code> is not continuous at the point <span class="math">$x=15/11$</span>.&#41;</p>

<pre class="julia-error">
ERROR: UndefVarError: CalculusWithJulia not defined
</pre>


  </div>
</div>

<script>
  document.querySelectorAll('pre.hljl').forEach(el => {   // first, find all the div.code blocks
  hljs.highlightElement(el);                              // then highlight each
  });

  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
  return new bootstrap.Tooltip(tooltipTriggerEl)
})
  var popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
  var popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
    return new bootstrap.Popover(popoverTriggerEl)
  });
</script>


</body>
</html>
